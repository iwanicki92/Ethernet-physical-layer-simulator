from typing import Any, SupportsFloat, Union, overload
import numpy as np
from PySpice.Tools.EnumFactory import EnumFactory as EnumFactory
from _typeshed import Incomplete

class UnitPrefixMetaclass(type):
    def __new__(meta, class_name, base_classes, attributes): ...
    @classmethod
    def register_prefix(meta, cls) -> None: ...
    @classmethod
    def prefix_iter(cls): ...
    @classmethod
    def get(cls, power): ...

class UnitPrefix(metaclass=UnitPrefixMetaclass):
    POWER: Incomplete
    PREFIX: str
    def __int__(self) -> int: ...
    @property
    def power(self): ...
    @property
    def prefix(self): ...
    @property
    def is_unit(self): ...
    @property
    def scale(self): ...
    @property
    def spice_prefix(self): ...
    @property
    def is_defined_in_spice(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __lt__(self, other): ...
    def __gt__(self, other): ...
    def str(self, spice: bool = ...): ...

class ZeroPower(UnitPrefix):
    POWER: int
    PREFIX: str
    SPICE_PREFIX: str

class SiDerivedUnit:
    BASE_UNITS: Incomplete
    def __init__(self, string: Incomplete | None = ..., powers: Incomplete | None = ...) -> None: ...
    @property
    def powers(self): ...
    @property
    def hash(self): ...
    @property
    def string(self): ...
    @classmethod
    def new_powers(cls): ...
    @classmethod
    def parse_si(cls, string): ...
    @classmethod
    def to_hash(cls, powers): ...
    @classmethod
    def to_string(cls, si_powers): ...
    def is_base_unit(self): ...
    def is_unit_less(self): ...
    def __bool__(self) -> bool: ...
    def clone(self): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __mul__(self, other): ...
    def __imul__(self, other): ...
    def __truediv__(self, other): ...
    def __itruediv__(self, other): ...
    def power(self, value): ...
    def reciprocal(self): ...
    def sqrt(self): ...
    def square(self): ...
    def cbrt(self): ...

class UnitMetaclass(type):
    def __new__(meta, class_name, base_classes, attributes): ...
    @classmethod
    def init_unit(meta, cls) -> None: ...
    @classmethod
    def register_unit(meta, cls) -> None: ...
    @classmethod
    def unit_iter(meta): ...
    @classmethod
    def from_prefix(meta, prefix): ...
    @classmethod
    def from_hash(meta, hash_): ...
    @classmethod
    def from_si_unit(meta, si_unit, unique: bool = ...): ...

class UnitError(ValueError): ...

class Unit(metaclass=UnitMetaclass):
    UNIT_NAME: str
    UNIT_SUFFIX: str
    QUANTITY: str
    SI_UNIT: Incomplete
    DEFAULT_UNIT: bool
    def __init__(self, si_unit: Incomplete | None = ...) -> None: ...
    @property
    def unit_name(self): ...
    @property
    def unit_suffix(self): ...
    @property
    def quantity(self): ...
    @property
    def si_unit(self): ...
    @property
    def is_unit_less(self): ...
    @classmethod
    def is_default_unit(cls): ...
    @classmethod
    def is_base_unit(cls): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def multiply(self, other, prefixed_unit: bool = ...): ...
    def divide(self, other, prefixed_unit: bool = ...): ...
    def power(self, exponent, prefixed_unit: bool = ...): ...
    def reciprocal(self, prefixed_unit: bool = ...): ...
    def sqrt(self, prefixed_unit: bool = ...): ...
    def square(self, prefixed_unit: bool = ...): ...
    def cbrt(self, prefixed_unit: bool = ...): ...
    def is_same_unit(self, value): ...
    def validate(self, value, none: bool = ...): ...

class SiBaseUnit(Unit):
    @classmethod
    def is_base_unit(cls): ...
    @classmethod
    def is_default_unit(cls): ...

class PrefixedUnit:
    @classmethod
    def register(cls, prefixed_unit) -> None: ...
    @classmethod
    def from_si_unit(cls, si_unit): ...
    @classmethod
    def from_prefixed_unit(cls, unit, power: int = ...): ...
    def __init__(self, unit: Incomplete | None = ..., power: Incomplete | None = ..., value_ctor: Incomplete | None = ..., values_ctor: Incomplete | None = ...) -> None: ...
    @property
    def unit(self): ...
    @property
    def power(self): ...
    @property
    def scale(self): ...
    @property
    def is_unit_less(self): ...
    def clone(self): ...
    def is_same_unit(self, other): ...
    def check_unit(self, other) -> None: ...
    def is_same_power(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def str(self, spice: bool = ..., unit: bool = ...): ...
    def str_spice(self): ...
    def new_value(self, value): ...

class UnitValue:
    @classmethod
    def simple_value(cls, value): ...
    def __init__(self, prefixed_unit, value: Union[UnitValue, int, SupportsFloat]) -> None: ...
    @property
    def prefixed_unit(self): ...
    @property
    def unit(self): ...
    @property
    def power(self): ...
    @property
    def scale(self): ...
    @property
    def value(self): ...
    def clone(self): ...
    def clone_prefixed_unit(self, value): ...
    def is_same_unit(self, other): ...
    def is_same_power(self, other): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    def __int__(self) -> int: ...
    def __float__(self) -> float: ...
    def str(self, spice: bool = ..., space: bool = ..., unit: bool = ...): ...
    def str_space(self): ...
    def str_spice(self): ...
    def __bool__(self) -> bool: ...
    @overload
    def __add__(self, other: UnitValue) -> UnitValue: ...  # type: ignore[misc]
    @overload
    def __add__(self, other: SupportsFloat) -> float: ...
    def __iadd__(self, other) -> UnitValue: ...  # type: ignore[misc]
    def __radd__(self, other): ...
    def __neg__(self): ...
    def __pos__(self): ...
    def __sub__(self, other): ...
    def __isub__(self, other): ...
    def __rsub__(self, other): ...
    def __mul__(self, other): ...
    def __imul__(self, other): ...
    def __rmul__(self, other): ...
    def __floordiv__(self, other): ...
    def __ifloordiv__(self, other): ...
    def __rfloordiv__(self, other): ...
    def __truediv__(self, other): ...
    def __itruediv__(self, other): ...
    def __rtruediv__(self, other): ...
    def __pow__(self, exponent): ...
    def __ipow__(self, exponent): ...
    def __rpow__(self, base) -> None: ...
    def __abs__(self): ...
    def __trunc__(self) -> None: ...
    def __divmod__(self, other): ...
    def __rdivmod__(self, other): ...
    def __mod__(self, other) -> None: ...
    def __rmod__(self, other) -> None: ...
    def __lt__(self, other): ...
    def __le__(self, other): ...
    def __ceil__(self): ...
    def __floor__(self): ...
    def __round__(self): ...
    def reciprocal(self): ...
    def get_prefixed_unit(self, power: int = ...): ...
    def convert(self, prefixed_unit): ...
    def convert_to_power(self, power: int = ...): ...
    def canonise(self): ...

class UnitValues(np.ndarray):
    CONVERSION: Incomplete
    UFUNC_MAP: Incomplete
    @classmethod
    def from_ndarray(cls, array, prefixed_unit): ...
    def __new__(cls, prefixed_unit, shape, dtype=..., buffer: Incomplete | None = ..., offset: int = ..., strides: Incomplete | None = ..., order: Incomplete | None = ...): ...
    def __array_finalize__(self, obj) -> None: ...
    def __array_ufunc__(self, ufunc, method, *inputs, **kwargs): ...
    def as_ndarray(self, scale: bool = ...): ...
    def __getitem__(self, slice_): ...
    def __setitem__(self, slice_, value) -> None: ...
    def __reduce__(self): ...
    def __contains__(self, value) -> bool: ...
    @property
    def prefixed_unit(self): ...
    @property
    def unit(self): ...
    @property
    def power(self): ...
    @property
    def scale(self): ...
    def is_same_unit(self, other): ...
    def is_same_power(self, other): ...
    def __eq__(self, other): ...
    def reciprocal(self): ...
    def get_prefixed_unit(self, power: int = ...): ...
    def convert(self, prefixed_unit): ...
    def convert_to_power(self, power: int = ...): ...

class FrequencyMixin:
    @property
    def period(self): ...
    @property
    def pulsation(self): ...

class PeriodMixin:
    @property
    def frequency(self): ...
    @property
    def pulsation(self): ...
